\chapter{Utilisation des variables}

\section{Une vraie calculatrice !}
Je l'ai déjà dit, mais un ordinateur n'est qu'une grosse calculatrice, et pour vous prouver que
je ne vous mène pas en bateau, nous allons nous en servir :
\subsection{Additionnons deux nombres}
Pour additionner deux nombres, on utilise l'opérateur plus, comme au primaire.
\begin{listing}
\begin{minted}[linenos]{swift}
let nombre1 = 64
let nombre2 = 36
let résultat = nombre1 + nombre2
// On initialise la constante résultat avec le résultat de l'addition des deux nombres.
let flottant = 1.5
let entier = 5
let resultat2 = flottant + Double(entier) // Conversion !
let pi = 3 + 0.141592 
// Ceci ne marche que parce que les nombres littéraux n'ont pas de type.
\end{minted}
\caption{Des additions}
\end{listing}

Attention, toutefois, au mélange des types. Pour additionner un entier et un nombre à virgule flottante il faut convertir  
\subsection{Soustraction et multiplication}
De même les bonnes vielles soustractions et multiplications fonctionnent, avec les mêmes règles de priorité des opérations en utilisant respectivement les opérateurs \verb"-" et \verb"*".
L'opérateur \verb"-" peut aussi âtre utilisé seul devant une variable numérique pour en obtenir l'opposé.
Exemple :
\begin{listing}
\begin{minted}[linenos]{swift}
let nombre1 = 10 * 10
let nombre2 = 6 * 6
let résultat = nombre1 - nombre2
// Pythagore à encore frappé. 
let moins_cent= -nombre1
\end{minted}
\caption{Multiplications et Soustractions}
\end{listing}

\subsection{Division et modulo}
La division, vous connaissez, mais vous allez surment me demander ce que j'entends par \emph{modulo}.

Il s'agit en fait du nom que les programmeurs donnent au \emph{reste} de la division euclidienne.

Commençons par la division.

Il est possible de diviser deux entiers pour obtenir un eniter, et deux nombres à virgule pour obtenir un nombre à virgule, attention, les trois du même type, à vous de faire des conversiuons si besoin est : \mintinline{swift}{LeBonType(<var_du_mauvais_type>) + var_du_bon_type}.
\begin{listing}[h]
\begin{minted}[linenos]{swift}
let entier = 49
let flottant = 5.0
let quotient_entier = entier / Int(flottant)
// Division d'entier : 9
let quotient_flottant = Double(entier) / flottant
// Division de flottants : 9.8
\end{minted}
\caption{Les deux divisions}
\end{listing}

Le modulo \mintinline{swift}{(a % b)} est défini tel que \mintinline{swift}{a = b * un_entier + (a % b)} ou \verb"un_entier" est le plus grand entier en valeur absolue (en ommetant le signe) tel que \verb"a % b" soit du signe de \verb"a". \verb"a % b", est donc, en valeur absolue (sans le signe), strictement plus petit que \verb"b".
(en supposant b, positif, mais s'il est négatif on a le même réultat que s'il était positif)

En Swift, contrairement à la plupart des langage, le modulo n'est pas réservé à deux entiers, il est aussi possible de l'appliquer à \emph{deux} nombres à virgule.

\begin{listing}[h]
\begin{minted}[linenos]{swift}
let entier = 49
let flottant = 5.0
let reste_entier = entier % Int(flottant)
// Division d'entier : 4
let reste_flottant = Double(entier) % 2.5
// Division de flottants : 1.5
\end{minted}
\caption{Le modulo, avec des entiers ou des flottants.}
\end{listing}

\subsection{Assignations augmentés}
J'avais aussi omis de vous le préciser, mais la qualité première du programmeur est la fainéantise. En fait je plaisante un peu, mais les programmeurs apprécient dès qu'ils ont moins à taper.
Par conséquent au lieu d'écrire \mintinline{swift}{a = a + 1}
Ils utilisent une notation raccourcis spéciale \mintinline{swift}{a += 1}

On appel ces opérateurs \emph{augmentés}. Ils existent pour les 5 opérateurs que nous avons déja vu :

\begin{longtabu} to \linewidth {|X[,l,m]|X[,l,m]|}
\hline Opérateurs augmenté & Opérateurs normal \\ \hline
\endhead
\mintinline{swift}{a += 1} & \mintinline{swift}{a = a + 1} \\ \hline
\mintinline{swift}{a -= 1} & \mintinline{swift}{a = a - 1} \\ \hline
\mintinline{swift}{a *= 2} & \mintinline{swift}{a = a * 2} \\ \hline
\mintinline{swift}{a /= 2} & \mintinline{swift}{a = a / 2} \\ \hline
\mintinline{swift}{a \%= 2} & \mintinline{swift}{a = a \% 2} \\ \hline
\caption{Les différents opérateurs augmentés}
\end{longtabu}

\subsection{Incrémenter et Décrémenter}
Comme les programmeurs sont vraiments très fainéants il existe deux opérateurs pour ajouter et enlever 1 à une variable : \mintinline{swift}{++} et \mintinline{swift}{--}, formes raccourcies respectives de \mintinline{swift}{+=1} et \mintinline{swift}{-=1}. Ils peuvent être placés avant ou après une variable, avec une légère différence en terme de priorité, dont nous parlerons dans le chapitre dédié aux opérateurs avancés.
\subsection{Les priorités}
Si vous mélangez les différentes opérations, les opérateurs normaux serons éxéécutés en suivant les priorités mathématiques, c'est à dire les multiplications, divisions et restes avant les additions et soustractions; et les assignations (éventuellement augmentées) en dernier.
Pour modifier cette ordre on utilise des parenthèses, comme dans une expression mathématiques.
\section{Première approche des fonctions}
Vous vous souvenez de la ligne affichant du texte, au chapitre 2. Je vais ici vous l'expliquer un peu plus en détail.
\subsection{Une fonction}
Pour le matheux : \emph{Une fonction associe à tout élément d'un ensemble de départ au plus un élément d'un ensemble d'arrivé}.

Pour le programmeur, une fonction c'est donc une sorte de boite noire, à laquelle on donne à manger des paramètres, \emph{de types bien définis}, et qui renvoi une valeur (ou rien du tout).

Une fonction sert à réutiliser un bout de code sans avoir à le recopier à chaque fois, et permet de ne pas avoir à savoir comment cela fonctionne.
On reviendra à l'utilité du découpage du code dans un chapitre ultérieur.

L'exemple que vous avez déja vu est la fonction \mintinline{swift}{println}, qui affiche une ligne de texte. Les conversion de type sont aussi à des fonctions.

\begin{listing}[h]
\begin{minted}[linenos]{swift}
let entier = 42
let flottant = Double(entier)
println("Bonjour tout le monde")
\end{minted}
\caption{Deux appels de fonctions}
\end{listing}

Un appel de fonction se présente sous la forme :
\begin{listing}[h]
\begin{minted}[linenos]{swift}
nom_de_la_fonction(<paramètre>[, <paramètre2 ...]) 
\end{minted}
\caption{forme générale d'un appel de fonction}
\end{listing}

Ici les noms correspondants sont \mintinline{swift}{Double} (le nom du type, en effet ...) et \mintinline{swift}{println}. La deuxième ne renvoie rien, tandis que la première renvoie un \mintinline{swift}{Double} (comme c'est original ...), que l'on récupère ici dans une variable, mais qui aurait pu être utilisé dans une autre expression, comme paramètre d'une autre fonction, ou dans une opération.

\subsection{Les Fonctions mathématiques}

Pour ceux qui connaissent un peu les maths, je vais ici vous donner la liste des fonctions disponibles dans Swift. Attention, ce ne sont pas de vraies fonctions au sens mathématiques, donc pas de dérivation, intégration, limite et autres.
Je ne détail pas toutes les fonctions, qui sont pour la plupart directement issue de celle disponible en C/C++.
Si vous êtes intéréssés par certaines, une simple recherche Google (ou autre) avec le nom de la fonction vous fournira les détails.
\begin{description}
\item[ceil, floor, round, trunc :] Arrondis respectif, au nombre entier supérieur, inférier, le plus proche et vers 0. Prend un flottant (Double ou Float), et renvoie un nombre du \emph{même type}.
\item[abs, fabs :] Cette bonne vieille fonction valeur absolue (Int et Double ou Float), renvoie un nombre positif égal à plus ou moins le paramètre en entrée.
\item[sqrt, cbrt :] Racines carrée et cubique.
\item[pow :] La fonction puissance, prend deux paramètre Double ou Float $x$ et $a$, et renvoie $x^{a}$. % Penser à faire un TP Opérateur **
\item[exp, exp2, expm1 :] Exponentielles d'un Double ou d'un Float
\item[log, log10, log1p, log2, logb :] Fonctions logarithmes, de Doubles et Floats.
\item[cos, cosh, sin, sinh, tan, tanh, acos, acosh, asin, asinh, atan, atanh, atan2 :] Les fonctions trigonométriques.
\item[erf, erfc, tgamma :] Fonctions mathématiques particulières.
\end{description}
Cette description sera peut-être encore étoffée.
