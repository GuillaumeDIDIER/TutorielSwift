\chapter{La logique booléenne et le type Bool}
Dans ce chapitre, nous allons voir comment vérifier si des conditions sont remplies dans notre programme, et découvrir la logique booléenne.

\section{Le type Bool}
Je vous ai mentionné à l'instant les conditions ;
l'heure est donc venue de vous introduire le type
\og qui va bien \fg{} pour stocker et manipuler les conditions.
Une condition peut être ou non vérifiée, elle peut donc prendre deux valeurs : \og vrai \fg{} ou \og faux\fg{}.
En Swift, le type \mintinline{swift}{Bool} correspond à cela. Un \mintinline{swift}{Bool}, du nom du mathématicien anglais du XIX\textsuperscript{e} George Boole,
inventeur de la logique booléenne, peut prendre les valeurs \mintinline{swift}{true} (\og vrai \fg{} en anglais) et \mintinline{swift}{false}.
\begin{listing}
\begin{minted}[linenos]{swift}
// Avec des constantes, rappel d'un chapitre précédent.
let les_oranges_sont_orange = true
let les_navets_sont_délicieux = false
\end{minted}
\caption{Deux booléens.}
\end{listing}
\section{Un peu de logique}
Je ne vous ferai pas un cours complet de logique, mais je vais tout de même vous montrer les trois opérateurs de bases,
du point de vu théorique, avant de vous les montrer en Swift.
Ça pourra toujours vous servir si vous avez un jour affaire à un vrai matheux, ou si vous en devenez un.


Pour toute la suite $A$ et $B$ désignent des booléens.
\subsection{La négation}
On appelle $non(A)$, le booléen qui est de la valeur opposée à $A$.
\begin{table}[h]
\centering
\begin{tabu} spread \linewidth {|l|r|}
\hline
$A$ & $non(A)$ \\ \hline
Vrai & Faux \\ \hline
Faux & Vrai \\ \hline
\end{tabu}
\caption{La négation.}
\end{table}
\subsection{La conjonction}
La conjonction que l'on note $A$ $et$ $B$, n'est vraie que si \textbf{à la fois} $A$ \textbf{et} $B$ sont vrais.
\begin{table}[h]
\centering
\begin{tabu} spread \linewidth {|l|l|r|}
\hline
$A$ & $B$ & $A$ $et$ $B$ \\ \hline
Vrai & Vrai & Vrai \\ \hline
Vrai & Faux & Faux \\ \hline
Faux & Vrai & Faux \\ \hline
Faux & Faux & Faux \\ \hline
\end{tabu}
\caption{La conjonction}
\end{table}
\subsection{La disjonction}
La disjonction que l'on note $A$ $ou$ $B$, est vraie si \textbf{au moins} l'un des deux booléens $A$ \textbf{ou} $B$ est vrai.
\begin{table}[h]
\centering
\begin{tabu} spread \linewidth {|l|l|r|}
\hline
$A$ & $B$ & $A$ $ou$ $B$ \\ \hline
Vrai & Vrai & Vrai \\ \hline
Vrai & Faux & Vrai \\ \hline
Faux & Vrai & Vrai \\ \hline
Faux & Faux & Faux \\ \hline
\end{tabu}
\caption{La disjonction.}
\end{table}
\subsection{Les lois de Morgan}
Dans cette section, nous allons aborder la négation respective d'une conjonction et d'une disjonction.

On a $non(A$ $et$ $B) = non(A)$ $ou$ $non(B)$,
et $non(A$ $ou$ $B) = non(A)$ $et$ $non(B)$.

\begin{table}[h]
\centering
\begin{tabu} spread \linewidth {|l|l|r|r|}
\hline
$A$ & $B$ & $A$ $ou$ $B$ & $non(A$ $ou$ $B)$ & $non(A)$ & $non(B)$ & $non(A)$ $et$ $non(B)$\\ \hline
Vrai & Vrai & Vrai & \textbf{Faux} & Faux & Faux & \textbf{Faux} \\ \hline
Vrai & Faux & Vrai & \textbf{Faux} & Faux & Vrai & \textbf{Faux} \\ \hline
Faux & Vrai & Vrai & \textbf{Faux} & Vrai & Faux & \textbf{Faux} \\ \hline
Faux & Faux & Faux & \textbf{Vrai} & Vrai & Vrai & \textbf{Vrai} \\ \hline
\end{tabu}
\caption{Démonstartion d'une des lois de Morgan.}
\end{table}


\subsection{Distributivité}
Comme avec certaines opérations mathématiques, il est possible de distribuer et de factoriser des expressions logiques.

La conjonction est \emph{distributive} par rapport à la disjonction.

$A$ $et$ $(B$ $ou$ $C) = (A$ $et$ $B)$ $ou$ $(A$ $et$ $C)$

Et la disjonction est aussi distributive par rapport à la conjonction.

$A$ $ou$ $(B$ $et$ $C) = (A$ $ou$ $B)$ $et$ $(A$ $ou$ $C)$

\section{Les opérateurs booléens en pratique}
\subsection{La négation}
La négation est représentée en Swift par l'opérateur (unaire préfix) \verb"!", qui se place immédiatement avant le booléen dont on veut la négation.
\begin{listing}[h]
\begin{minted}[linenos]{swift}
let le_plat_du_jour_est_dégoûtant = true
// Ou false si votre cantine vous gâte.
let je_vais_apprécier_mon_repas = !le_plat_du_jour_est_dégoûtant
\end{minted}
\caption{Négation.}
\end{listing}
\subsection{La conjonction}
En Swift la conjonction (ET), s'exprime avec l'opérateur (binaire) \verb"&&", qui se place entre les deux booléens dont on souhaite obtenir la conjonction.

\begin{listing}[h]
\begin{minted}[linenos]{swift}
// À l'entré d'un complexe militaire par exemple.
let peut_rentrer = connaît_le_mot_de_passe && a_des_papiers_en_ordre
\end{minted}
\caption{Conjonction.}
\end{listing}
\subsection{La disjonction}
En Swift la disjonction (OU), s'exprime avec l'opérateur (binaire) \verb"||" (ce symbole s'obtient en appuyant sur \verb"Alt" + \verb"Shift" + \verb"L", ou \verb"AltGr" + \verb"6" si vous avez l'idée saugrenue de faire du Swift sous Windows ou Linux), qui se place entre les deux booléens dont on souhaite obtenir la disjonction.

\begin{listing}[h]
\begin{minted}[linenos]{swift}
// Dédicace à l'auteur du tutoriel qui m'a lancé dans la programmation.
// Pour ouvrir un compte en banque il faut être assez âgé ou avoir beaucoup d'argent !
let peut_ouvrir_un_compte_chez_Picsou_Banque = 
est_assez_vieux || est_très_riche
\end{minted}
\caption{Disjonction.}
\end{listing}

\subsection{Les priorités}
La négation est prioritaire par rapport aux opération mathématiques, prioritaires par rapport à la conjonction qui est elle même prioritaire sur la disjonction. Les parenthèses sont toujours utilisable pour contrôler la priorité.

\emph{Comme cette dernière priorité n'est pas évidente, je vous recommande de toujours mettre des parenthèses, comme si rien n'était spécifié à propos des priorité entre conjonction et disjonction. C'est aussi ce qu'\emph{Apple} recommande.}
\section{Les tests}
<< \emph{C'est bien joli les booléens, mais comment on en fabrique à partir d'autre chose ?}>>
Il faut savoir que certains types peuvent se convertir en booléens, mais pas tous, mais il est heureusement possible de tester une condition sur deux objets et d'obtenir un booléen.
\subsection{Égalité et inégalité}
Pour tester si deux objets sont égaux (ont la même valeur),
on utilise \verb"==". Attention à bien mettre \emph{deux} signes égal, pour distinguer cela de l'affectation d'une valeur à une variable. Pour  en obtenir la négation, l'opérateur \verb"!=" existe aussi. On a bien \mintinline{swift}{(a != b) == !(a == b)}

On peut, entre autre, l'appliquer à des entiers, des nombres à virgule et des chaînes de caractères.
\subsection{Relation d'ordre}
Pour un certain nombre d'objets, il y a du sens à les ordonner.
Je vous passe la définition mathématique qui correspond, mais pour les types entiers et les nombres à virgule flottante la définition est bien celle que vous connaissez du primaire.
Les opérateurs d'ordre sont au nombre de 4.
\begin{itemize}
\item \verb">", strictement supérieur à,
\item \verb"<", strictement inférieur à,
\item \verb">=", supérieur ou égal à,
\item \verb"<=", inférieur ou égal à,
\end{itemize}

\begin{listing}[h]
\begin{minted}[linenos]{swift}
print("2 > 3 ? \(2 > 3)")
print("2.5 > 2.4 ? \(2.5 > 2.4)")
let trois /*: Int */ = 3
print("2.3 < 3 ? \(2.3 < Double(trois))") // Conversion nécessaire.
print(" (5 * 3) >= 15 \((5 * 3) >= 15)")
print(" (5 * 3) <= 15 \((5 * 3) <= 15)")
// Un nombre qui est à la fois plus petit et plus grand qu’un autre lui est égal !

\end{minted}
\caption{Quelques tests.}
\end{listing}%\) Stupid syntactic coloration !
\subsection{Priorités}
Tous les tests ont la même priorité
(et s'exécutent de gauche à droite),
qui est supérieurs à la conjonction (et à la disjonction),
mais inférieur aux opérateurs mathématiques.



J'ai laissé quelques tests de côté, moins intéressants pour vous dans l'immédiat : ils seront traités plus tard.
\section{L'évaluation raccourcie}
Pour optimiser les programmes, lorsque l'ordinateur peut conclure en ayant évalué que le premier opérande, il n'évalue pas le deuxième. C'est le cas pour \mintinline{swift}{A && B} si \mintinline{swift}{A == false},
et pour \mintinline{swift}{A || B} si \mintinline{swift}{A == true}.
Ce comportement est garanti par le langage.

On appelle cela l'évaluation raccourcie ou \emph{short-circuit}

Il est important de tenir compte de ce phénomène lorsque les expressions booléennes évaluées sont complexes, notamment lorsqu'elles contiennent des appels de fonctions. On en parlera lorsque j'évoquerai les effets de bord.

\section*{Conclusion}
\phantomsection
\addcontentsline{toc}{section}{Conclusion}
Dans cette partie vous avez appris :
\begin{itemize}
\item ce qu'est un booléen ;
\item quelles sont les opérations sur les booléens et leurs propriétés ;
\item comment en pratique utiliser ces opération ;
\item comment obtenir des booléens ;
\item ce qu'est l'évaluation raccourcie (\emph{short-circuit}).
\end{itemize}
\section*{Exercices}
\phantomsection
\addcontentsline{toc}{section}{Exercices}
Je vous propose d'écrire un bout de code qui, étant donné un nombre,
détermine s'il est pair ou impair, stocke le résultat dans un \mintinline{swift}{Bool}, par exemple \mintinline{swift}{estPair}, et affiche :
\begin{verbatim}
Le nombre … est pair : true/false.
Le nombre … est impair : true/false.
\end{verbatim}

%À dé-commenter si besoin, ou si l’on veut être gentil
%\pagebreak
%Un peu d’aide : on peut déterminer si un nombre est pair ou impair grâce au reste de sa division par deux.